import React, { useEffect, useMemo, useRef, useState } from "react";
import { Canvas, useFrame } from "@react-three/fiber";
import { Html } from "@react-three/drei";
import * as THREE from "three";

/**
 * Loop Run: Tower of Luck (3D) â€” Mobile-first
 * --------------------------------------------------------------
 * ë³€ê²½ ìš”ì•½(ëª¨ë°”ì¼ ìµœì í™”):
 * - í„°ì¹˜ ì»¨íŠ¸ë¡¤: í™”ë©´ ì¢Œ/ìš° í„°ì¹˜ë¡œ íšŒì „, í•˜ë‹¨ ëŒ€ì‰¬ ë²„íŠ¼, ë³´ìŠ¤ ë£°ë › ë²„íŠ¼ ìœ ì§€
 * - DPR ì œí•œ: dpr={[1,1.5]}ë¡œ ë°œì—´/ë°°í„°ë¦¬ ì ˆì•½
 * - UI í¬ê¸°/ê°„ê²© ëª¨ë°”ì¼ ê¸°ì¤€ ì¬ì¡°ì •, í„°ì¹˜ ì˜ì—­(íˆ¬ëª…) ì¶”ê°€
 * - ì¦‰ì‹œ ì¬ì‹œì‘/ìŠ¤í‚¨/ì§„í–‰ë„/ê´‘ê³ /IAP í›… ê·¸ëŒ€ë¡œ ìœ ì§€
 * - í‚¤ë³´ë“œ(WASD/í™”ì‚´í‘œ/Space)ë„ ë°ìŠ¤í¬í†±ì—ì„œ ê·¸ëŒ€ë¡œ ë™ì‘
 *
 * ì¡°ì‘(ëª¨ë°”ì¼):
 * - í™”ë©´ ì™¼ìª½ í„°ì¹˜: ì¢ŒíšŒì „ / í™”ë©´ ì˜¤ë¥¸ìª½ í„°ì¹˜: ìš°íšŒì „
 * - í•˜ë‹¨ [ëŒ€ì‰¬] ë²„íŠ¼: Spaceì™€ ë™ì¼
 * - [ë³´ìŠ¤ ë£°ë ›] ë²„íŠ¼: ë³´ìŠ¤ì¸µì—ì„œ ì½”ì¸ 5ê°œ ì†Œëª¨, 60% í™•ë¥ 
 */

/***********************
 * ìœ í‹¸ & ìƒìˆ˜
 ***********************/
const TAU = Math.PI * 2;
const FLOOR_HEIGHT = 3; // 1ì¸µ ë†’ì´(m)
const TRACK_RADIUS = 4.2; // ì›í˜• íŠ¸ë™ ë°˜ì§€ë¦„
const SEGMENTS_PER_FLOOR = 10; // í•œ ì¸µì—ì„œ ë°°ì¹˜ ìŠ¬ë¡¯ ê°œìˆ˜
const OBSTACLE_RATE = 0.25; // ì¥ì• ë¬¼ ìŠ¤í° í™•ë¥ 
const COIN_RATE = 0.35; // ì½”ì¸ ìŠ¤í° í™•ë¥ 
const CLOVER_RATE = 0.05; // í–‰ìš´ ì•„ì´í…œ ìŠ¤í° í™•ë¥ 
const BASE_ASCEND_SPEED = 2.0; // ì´ˆë‹¹ ìƒìŠ¹ m/s
const TURN_SPEED = 1.8; // ì¢Œìš° íšŒì „ ì†ë„ (rad/s)
const DASH_COOLDOWN = 1.2; // ì´ˆë‹¨ìœ„
const BOSS_FLOOR_INTERVAL = 33;
const RNG = (seed = 1) => {
  // xorshift32 ê¸°ë°˜ ê°„ë‹¨ ì‹œë“œ RNG
  let x = seed >>> 0;
  return () => {
    x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
    return (x >>> 0) / 0xffffffff;
  };
};

function useKeyPress() {
  const pressed = useRef({});
  useEffect(() => {
    const onDown = (e) => { pressed.current[e.code] = true; };
    const onUp = (e) => { pressed.current[e.code] = false; };
    window.addEventListener("keydown", onDown);
    window.addEventListener("keyup", onUp);
    return () => { window.removeEventListener("keydown", onDown); window.removeEventListener("keyup", onUp); };
  }, []);
  return pressed;
}

/***********************
 * ì§„í–‰ë„ & ìƒì  (ë¡œì»¬ ì €ì¥)
 ***********************/
const STORAGE_KEY = "looprun_progress_v1";
function loadProgress() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch { return null; }
}
function saveProgress(p) {
  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(p)); } catch {}
}

const SKINS = [
  { id: "default", name: "ê¸°ë³¸ í—ˆì ‘ì´", cond: { type: "always" }, price: 0 },
  { id: "golden", name: "ê¸ˆë¹› í—ˆì ‘ì´", cond: { type: "coins", n: 100 }, price: 0 },
  { id: "neon", name: "í˜•ê´‘ í—ˆì ‘ì´", cond: { type: "floor", n: 100 }, price: 0 },
  { id: "clover", name: "í´ë¡œë²„ í—ˆì ‘ì´", cond: { type: "luckWin", n: 3 }, price: 0 },
  { id: "pirate", name: "í•´ì  í—ˆì ‘ì´", cond: { type: "buy", sku: "skin_pirate", priceKRW: 1000 }, price: 1000 },
];

function evaluateSkins(progress) {
  const unlocked = new Set(progress.unlockedSkins || ["default"]);
  const flags = { coins: progress.totalCoins || 0, floor: progress.bestFloor || 0, luckWin: progress.luckBossWins || 0 };
  SKINS.forEach(s => {
    if (unlocked.has(s.id)) return;
    const c = s.cond;
    if (c.type === "always") unlocked.add(s.id);
    if (c.type === "coins" && flags.coins >= c.n) unlocked.add(s.id);
    if (c.type === "floor" && flags.floor >= c.n) unlocked.add(s.id);
    if (c.type === "luckWin" && flags.luckWin >= c.n) unlocked.add(s.id);
    if (c.type === "buy" && progress.purchasedSkus?.includes?.(c.sku)) unlocked.add(s.id);
  });
  return Array.from(unlocked);
}

/***********************
 * ìƒì /IAP ìŠ¤í…
 ***********************/
function useIAP() {
  const buy = async (sku, priceKRW) => {
    const ok = window.confirm(`í…ŒìŠ¤íŠ¸ ê²°ì œ: ${sku}ë¥¼ \${priceKRW}ì— êµ¬ë§¤í•˜ì‹œê² ì–´ìš”? (ëª¨ì˜)`);
    return ok;
  };
  const showRewardedAd = async () => {
    const ok = window.confirm("ë¦¬ì›Œë“œ ê´‘ê³ ë¥¼ ì‹œì²­í–ˆë‹¤ê³  ê°€ì •í• ê¹Œìš”? (ëª¨ì˜)");
    return ok;
  };
  return { buy, showRewardedAd };
}

/***********************
 * ë ˆë²¨/ìŠ¤í°ëŸ¬
 ***********************/
function generateRingLayout(rng) {
  const r = rng();
  if (r < CLOVER_RATE) return "clover";
  if (r < CLOVER_RATE + COIN_RATE) return "coin";
  if (r < CLOVER_RATE + COIN_RATE + OBSTACLE_RATE) return "obstacle";
  return "none";
}

function useSpawner(seed) {
  const rng = useMemo(() => RNG(seed), [seed]);
  const getRing = (floorIndex) => {
    if ((floorIndex + 1) % BOSS_FLOOR_INTERVAL === 0) {
      return { type: "boss", items: Array(SEGMENTS_PER_FLOOR).fill("coin") };
    }
    const items = new Array(SEGMENTS_PER_FLOOR).fill(0).map(() => generateRingLayout(rng));
    return { type: "normal", items };
  };
  return { getRing };
}

/***********************
 * 3D íŒŒì¸ 
 ***********************/
function JankyDude({ skin = "default" }) {
  const group = useRef();
  const bodyColor = skin === "golden" ? "#f2c94c"
                      : skin === "neon" ? "#60a5fa"
                      : skin === "clover" ? "#34d399"
                      : skin === "pirate" ? "#111827"
                      : "#d1d5db";
  const accent = skin === "pirate" ? "#ef4444" : "#111827";
  return (
    <group ref={group}>
      <mesh position={[0, 0.6, 0]} frustumCulled={false}>
        <boxGeometry args={[0.8, 1.2, 0.4]} />
        <meshStandardMaterial color={bodyColor} roughness={0.9} metalness={skin==="golden"?0.5:0.1} />
      </mesh>
      <mesh position={[0, 1.5, 0]}>
        <sphereGeometry args={[0.35, 12, 12]} />
        <meshStandardMaterial color="#ffffff" roughness={0.8} />
      </mesh>
      <mesh position={[-0.1, 1.55, 0.29]}>
        <circleGeometry args={[0.05, 16]} />
        <meshStandardMaterial color={accent} />
      </mesh>
      <mesh position={[0.15, 1.52, 0.29]}>
        <circleGeometry args={[0.05, 16]} />
        <meshStandardMaterial color={accent} />
      </mesh>
      <mesh position={[-0.2, 0.0, 0]}>
        <boxGeometry args={[0.15, 0.6, 0.15]} />
        <meshStandardMaterial color="#6b7280" />
      </mesh>
      <mesh position={[0.2, 0.0, 0]}>
        <boxGeometry args={[0.15, 0.6, 0.15]} />
        <meshStandardMaterial color="#6b7280" />
      </mesh>
      {skin === "pirate" && (
        <mesh position={[0, 1.6, 0]} rotation={[0,0,0.1]}>
          <boxGeometry args={[0.7, 0.1, 0.1]} />
          <meshStandardMaterial color={accent} />
        </mesh>
      )}
    </group>
  );
}

function Coin({ position = [0,0,0] }) {
  const ref = useRef();
  useFrame((_, dt) => { if (ref.current) ref.current.rotation.y += dt * 2; });
  return (
    <group position={position}>
      <mesh ref={ref}>
        <torusGeometry args={[0.18, 0.07, 12, 24]} />
        <meshStandardMaterial color="#fbbf24" metalness={0.6} roughness={0.3} />
      </mesh>
    </group>
  );
}
function Clover({ position=[0,0,0] }) {
  const ref = useRef();
  useFrame((_, dt) => { if (ref.current) ref.current.rotation.y += dt * 1.2; });
  return (
    <group position={position} ref={ref}>
      <mesh>
        <sphereGeometry args={[0.15, 12, 12]} />
        <meshStandardMaterial color="#10b981" />
      </mesh>
    </group>
  );
}
function Obstacle({ position=[0,0,0] }) {
  return (
    <mesh position={position}>
      <boxGeometry args={[0.7, 0.7, 0.7]} />
      <meshStandardMaterial color="#ef4444" roughness={0.6} />
    </mesh>
  );
}
function BossGate({ y }) {
  return (
    <group position={[0, y + 1.2, 0]}>
      <mesh rotation={[Math.PI/2, 0, 0]}>
        <torusGeometry args={[TRACK_RADIUS * 0.9, 0.35, 12, 48]} />
        <meshStandardMaterial color="#8b5cf6" metalness={0.2} roughness={0.6} />
      </mesh>
      <mesh position={[-1.5, 1.4, TRACK_RADIUS*0.9-0.2]}>
        <sphereGeometry args={[0.25, 12, 12]} />
        <meshStandardMaterial color="#111827" />
      </mesh>
      <mesh position={[1.5, 1.4, TRACK_RADIUS*0.9-0.2]}>
        <sphereGeometry args={[0.25, 12, 12]} />
        <meshStandardMaterial color="#111827" />
      </mesh>
    </group>
  );
}
function Tower({ windowFloors = 80, baseFloor = 0 }) {
  const group = useRef();
  const pillars = useMemo(() => {
    const arr = [];
    for (let i = 0; i < windowFloors; i++) {
      const y = (baseFloor + i) * FLOOR_HEIGHT;
      arr.push({ y });
    }
    return arr;
  }, [windowFloors, baseFloor]);
  return (
    <group ref={group}>
      {pillars.map((p, i) => (
        <mesh key={i} position={[0, p.y, 0]} rotation={[Math.PI/2, 0, 0]}>
          <ringGeometry args={[TRACK_RADIUS*0.95, TRACK_RADIUS*1.05, 48]} />
          <meshStandardMaterial color={i%2===0?"#e5e7eb":"#f3f4f6"} side={THREE.DoubleSide} />
        </mesh>
      ))}
    </group>
  );
}

/***********************
 * ê²Œì„ ë£¨í”„
 ***********************/
function Scene3D({ running, onHit, onCollectCoin, onCollectClover, seed, floorRef, bossState, onBossEnter, skin }) {
  const pressed = useKeyPress();
  const { getRing } = useSpawner(seed);

  // í”Œë ˆì´ì–´ ìƒíƒœ
  const theta = useRef(0); // ê°ë„
  const y = useRef(0); // ë†’ì´
  const speedY = useRef(BASE_ASCEND_SPEED);
  const dash = useRef({ cd: 0 });

  // ìŠ¤í° ìºì‹œ
  const ringsRef = useRef(new Map());

  // ì¹´ë©”ë¼
  const camRef = useRef();
  const playerRef = useRef();

  const playerPos = () => new THREE.Vector3(Math.cos(theta.current) * TRACK_RADIUS, y.current + 1.2, Math.sin(theta.current) * TRACK_RADIUS);

  useFrame((state, dt) => {
    if (!running) return;
    // ì…ë ¥(í‚¤ë³´ë“œ)
    const left = pressed.current["ArrowLeft"] || pressed.current["KeyA"] || pressed.current.__touchLeft;
    const right = pressed.current["ArrowRight"] || pressed.current["KeyD"] || pressed.current.__touchRight;
    if (left) theta.current -= TURN_SPEED * dt;
    if (right) theta.current += TURN_SPEED * dt;

    if (dash.current.cd > 0) dash.current.cd -= dt;
    const dashPressed = pressed.current["Space"] || pressed.current.__touchDash;
    if (dashPressed && dash.current.cd <= 0) {
      y.current += 2.2;
      dash.current.cd = DASH_COOLDOWN;
      pressed.current.__touchDash = false; // ì›íƒ­ ì²˜ë¦¬
    }

    // ìƒìŠ¹
    y.current += speedY.current * dt;

    // ì¸µ
    const currentFloor = Math.floor(y.current / FLOOR_HEIGHT);
    floorRef.current = currentFloor + 1;

    // ë³´ìŠ¤ ì²´í¬
    const bossFloor = (currentFloor + 1) % BOSS_FLOOR_INTERVAL === 0;
    if (bossFloor && bossState.current === "none") {
      bossState.current = "entered";
      onBossEnter(currentFloor + 1);
    }

    // ì¹´ë©”ë¼ ì¶”ì 
    if (camRef.current) {
      const p = playerPos();
      camRef.current.position.lerp(new THREE.Vector3(p.x, p.y + 4.0, p.z + 6.5), 0.15);
      camRef.current.lookAt(p.x, p.y, p.z);
    }

    // ì¶©ëŒ/ìˆ˜ì§‘ ì²´í¬
    const ringIndex = currentFloor;
    if (!ringsRef.current.has(ringIndex)) ringsRef.current.set(ringIndex, getRing(ringIndex));
    const ring = ringsRef.current.get(ringIndex);

    let a = theta.current % TAU; if (a < 0) a += TAU;
    const seg = Math.floor((a / TAU) * SEGMENTS_PER_FLOOR);

    if (ring.type === "boss") {
      if (bossState.current !== "cleared") {
        const gateY = ringIndex * FLOOR_HEIGHT;
        if (Math.abs(y.current - gateY - 1.2) < 0.6) {
          onHit("boss");
        }
      }
    } else {
      const item = ring.items[seg];
      if (item && item !== "none") {
        if (Math.abs((y.current % FLOOR_HEIGHT) - 1.2) < 0.5) {
          if (item === "coin") { onCollectCoin(); ring.items[seg] = "none"; }
          else if (item === "clover") { onCollectClover(); ring.items[seg] = "none"; }
          else if (item === "obstacle") { onHit("obstacle"); }
        }
      }
    }

    // í”Œë ˆì´ì–´ ìœ„ì¹˜
    if (playerRef.current) {
      const p = playerPos();
      playerRef.current.position.copy(p);
      playerRef.current.lookAt(0, p.y, 0);
    }
  });

  const currentBaseFloor = Math.max(0, Math.floor(y.current / FLOOR_HEIGHT) - 5);

  return (
    <>
      <perspectiveCamera ref={camRef} position={[0, 4, 10]} fov={55} />
      <ambientLight intensity={0.7} />
      <directionalLight position={[5, 10, 5]} intensity={0.8} />

      <Tower windowFloors={80} baseFloor={currentBaseFloor} />

      {Array.from({ length: 100 }).map((_, i) => {
        const rIndex = currentBaseFloor + i;
        if (!ringsRef.current.has(rIndex)) ringsRef.current.set(rIndex, getRing(rIndex));
        const ring = ringsRef.current.get(rIndex);
        const baseY = rIndex * FLOOR_HEIGHT + 1.2;
        const nodes = [];
        if (ring.type === "boss") {
          nodes.push(<BossGate key={`boss-${rIndex}`} y={rIndex*FLOOR_HEIGHT} />);
        } else {
          for (let s = 0; s < SEGMENTS_PER_FLOOR; s++) {
            const ang = (s / SEGMENTS_PER_FLOOR) * TAU;
            const x = Math.cos(ang) * TRACK_RADIUS;
            const z = Math.sin(ang) * TRACK_RADIUS;
            const item = ring.items[s];
            const k = `${rIndex}-${s}`;
            if (item === "coin") nodes.push(<Coin key={`c-${k}`} position={[x, baseY, z]} />);
            if (item === "clover") nodes.push(<Clover key={`l-${k}`} position={[x, baseY, z]} />);
            if (item === "obstacle") nodes.push(<Obstacle key={`o-${k}`} position={[x, baseY, z]} />);
          }
        }
        return nodes;
      })}

      <group>
        <group>
          <JankyDude skin={skin} />
        </group>
      </group>
    </>
  );
}

/***********************
 * ë©”ì¸ ì»´í¬ë„ŒíŠ¸
 ***********************/
export default function App() {
  const [running, setRunning] = useState(false);
  const [seed, setSeed] = useState(() => Math.floor(Math.random() * 999999) + 1);
  const [coins, setCoins] = useState(0);
  const [cloverBuff, setCloverBuff] = useState({ active: false, until: 0 });
  const [hudMsg, setHudMsg] = useState("");
  const [skin, setSkin] = useState("default");

  const floorRef = useRef(1);
  const bossState = useRef("none");

  const [progress, setProgress] = useState(() => {
    const p = loadProgress();
    return p || { bestFloor: 0, totalCoins: 0, luckBossWins: 0, purchasedSkus: [], unlockedSkins: ["default"], lastSkin: "default" };
  });

  useEffect(() => {
    const unlocked = evaluateSkins(progress);
    if (!unlocked.includes(progress.lastSkin)) setSkin("default");
    else setSkin(progress.lastSkin || "default");
    saveProgress({ ...progress, unlockedSkins: unlocked });
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  useEffect(() => { saveProgress(progress); }, [progress]);

  const startGame = () => {
    setCoins(0);
    setCloverBuff({ active: false, until: 0 });
    setHudMsg("");
    bossState.current = "none";
    setSeed(Math.floor(Math.random() * 999999) + 1);
    setRunning(true);
  };
  const endGame = (reason = "hit") => {
    setRunning(false);
    const floor = floorRef.current;
    setProgress(p => ({ ...p, bestFloor: Math.max(p.bestFloor || 0, floor), totalCoins: (p.totalCoins || 0) + coins }));
    setHudMsg(reason === "boss" ? "ë³´ìŠ¤ì—ê²Œ íŠ•ê²¨ë‚¬ì–´ìš”! ë£°ë ›ìœ¼ë¡œ ëš«ì–´ë³´ì" : "ìœ¼ì•…! ë¶€ë”ªí˜”ì–´ìš”");
  };

  const onHit = (type) => {
    if (cloverBuff.active && Date.now() < cloverBuff.until) return; // ë¬´ì 
    endGame(type === "boss" ? "boss" : "hit");
  };
  const onCollectCoin = () => setCoins(c => c + 1);
  const onCollectClover = () => {
    setCloverBuff({ active: true, until: Date.now() + 4000 });
    setHudMsg("í´ë¡œë²„! ì ê¹ ë¬´ì âœ¨");
    setTimeout(() => setHudMsg(""), 1200);
  };

  const doBossLuck = () => {
    const floor = floorRef.current;
    if (floor % BOSS_FLOOR_INTERVAL !== 0) {
      setHudMsg("ë³´ìŠ¤ì¸µì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥"); setTimeout(() => setHudMsg(""), 900); return;
    }
    if (coins < 5) { setHudMsg("ì½”ì¸ 5ê°œ í•„ìš”"); setTimeout(() => setHudMsg(""), 900); return; }
    setCoins(c => c - 5);
    const win = Math.random() < 0.6;
    if (win) {
      bossState.current = "cleared";
      setHudMsg("í–‰ìš´ì˜ ëŒ€ì„±ê³µ! ê²Œì´íŠ¸ OPENğŸ’¥");
      setTimeout(() => setHudMsg(""), 1200);
      setProgress(p => ({ ...p, luckBossWins: (p.luckBossWins||0) + 1 }));
    } else {
      setHudMsg("ì•—, ê½! ë‹¤ì‹œ ë„ì „");
      setTimeout(() => setHudMsg(""), 900);
    }
  };

  // ìƒì /ìŠ¤í‚¨
  const { buy, showRewardedAd } = useIAP();
  const unlocked = evaluateSkins(progress);
  const equipSkin = (id) => { if (unlocked.includes(id)) { setSkin(id); setProgress(p => ({ ...p, lastSkin: id, unlockedSkins: unlocked })); } };
  const purchaseSkin = async (skinId) => {
    const s = SKINS.find(x => x.id === skinId);
    if (!s || s.cond?.type !== "buy") return;
    const ok = await buy(s.cond.sku, s.cond.priceKRW);
    if (ok) setProgress(p => ({ ...p, purchasedSkus: [...(p.purchasedSkus||[]), s.cond.sku] }));
  };
  const claimAdCoins = async () => { const ok = await showRewardedAd(); if (ok) setCoins(c => c + 10); };

  // í„°ì¹˜ ì»¨íŠ¸ë¡¤: ì¢Œ/ìš° íŒ¨ë“œ + ëŒ€ì‰¬ ë²„íŠ¼
  const pressed = useKeyPress();
  const touchLeftRef = useRef(false);
  const touchRightRef = useRef(false);

  const onTouchStart = (e) => {
    for (const t of e.changedTouches) {
      const x = t.clientX; const w = window.innerWidth;
      if (x < w * 0.5) touchLeftRef.current = true; else touchRightRef.current = true;
    }
    pressed.current.__touchLeft = touchLeftRef.current;
    pressed.current.__touchRight = touchRightRef.current;
  };
  const onTouchMove = (e) => {
    // ì´ë™ ì¤‘ ì†ê°€ë½ì´ ì¢Œ/ìš° ì˜ì—­ ë„˜ì–´ê°€ë©´ ë°©í–¥ ì „í™˜
    const t = e.touches[0]; if (!t) return;
    const x = t.clientX; const w = window.innerWidth;
    touchLeftRef.current = x < w * 0.5; touchRightRef.current = !touchLeftRef.current;
    pressed.current.__touchLeft = touchLeftRef.current;
    pressed.current.__touchRight = touchRightRef.current;
  };
  const onTouchEnd = () => {
    touchLeftRef.current = false; touchRightRef.current = false;
    pressed.current.__touchLeft = false; pressed.current.__touchRight = false;
  };

  const doDash = () => { pressed.current.__touchDash = true; setTimeout(() => (pressed.current.__touchDash = false), 80); };

  // iOS ì£¼ì†Œì°½ ìˆ¨ê¹€/ì•ˆì „ì˜ì—­ ëŒ€ì‘ ë ˆì´ì•„ì›ƒ
  return (
    <div className="w-full h-dvh bg-[#0b1020] text-white select-none relative" onTouchStart={onTouchStart} onTouchMove={onTouchMove} onTouchEnd={onTouchEnd}>
      {/* ìƒë‹¨ HUD */}
      <div className="absolute inset-x-0 top-0 z-20 flex items-center justify-between p-3">
        <div className="flex items-center gap-2">
          <span className="text-[11px] opacity-70">ì¸µ</span>
          <span className="text-2xl font-bold">{floorRef.current}</span>
        </div>
        <div className="flex items-center gap-2">
          <div className="px-2 py-1 bg-[#111827] rounded-xl text-sm">ğŸª™ {coins}</div>
          {cloverBuff.active && Date.now() < cloverBuff.until && (
            <div className="px-2 py-1 bg-green-600 rounded-xl text-xs">â˜˜ ë¬´ì </div>
          )}
        </div>
      </div>

      {/* 3D ìº”ë²„ìŠ¤ */}
      <Canvas shadows dpr={[1,1.5]}>
        <color attach="background" args={[0.04, 0.06, 0.12]} />
        <fog attach="fog" args={[0x0b1020, 10, 100]} />
        <Scene3D
          running={running}
          onHit={onHit}
          onCollectCoin={onCollectCoin}
          onCollectClover={onCollectClover}
          seed={seed}
          floorRef={floorRef}
          bossState={bossState}
          onBossEnter={() => setHudMsg("ë³´ìŠ¤! ë£°ë ›(ì½”ì¸x5)")}
          skin={skin}
        />
        {!running && (
          <Html center>
            <div className="flex flex-col items-center gap-3 bg-black/45 backdrop-blur-sm p-4 rounded-2xl shadow-xl w-[86vw] max-w-[420px]">
              <div className="text-lg font-semibold">Tower of Luck</div>
              <div className="text-[11px] opacity-80 text-center">ì¢Œ/ìš° í™”ë©´ì„ í„°ì¹˜í•´ ì´ë™ Â· í•˜ë‹¨ ëŒ€ì‰¬ ë²„íŠ¼ Â· ë³´ìŠ¤ì¸µì—ì„œ ë£°ë ›</div>
              <button onClick={startGame} className="px-4 py-2 rounded-xl bg-indigo-500 hover:bg-indigo-400 transition w-full">í”Œë ˆì´</button>
              <div className="text-sm opacity-80 mt-1">Best Floor: {progress.bestFloor||0} Â· Total Coins: {progress.totalCoins||0}</div>
              {hudMsg && <div className="text-sm text-yellow-300">{hudMsg}</div>}
            </div>
          </Html>
        )}
        {hudMsg && running && (
          <Html position={[0, 5, 0]}>
            <div className="px-3 py-1 bg-black/40 rounded-full text-sm">{hudMsg}</div>
          </Html>
        )}
      </Canvas>

      {/* í•˜ë‹¨ ì»¨íŠ¸ë¡¤ ë°” (ëª¨ë°”ì¼ í¬ê¸° ì¡°ì •) */}
      <div className="absolute inset-x-0 bottom-0 z-20 p-3 pb-[max(12px,env(safe-area-inset-bottom))]">
        <div className="bg-black/35 backdrop-blur-sm rounded-2xl p-3 grid grid-cols-2 gap-3">
          {/* ìŠ¤í‚¨/ìƒì  */}
          <div className="flex flex-col gap-2">
            <div className="text-[11px] opacity-70">Skin</div>
            <div className="flex gap-2 flex-wrap">
              {SKINS.map(s => {
                const isUnlocked = evaluateSkins(progress).includes(s.id);
                return (
                  <button key={s.id}
                    onClick={() => isUnlocked ? equipSkin(s.id) : purchaseSkin(s.id)}
                    className={`px-2 py-1 rounded-xl text-[11px] border ${skin===s.id?"bg-white text-black":"bg-black/40"} ${isUnlocked?"border-white/30":"border-yellow-400"}`}>
                    {s.name}{!isUnlocked && s.cond?.type==="buy"?` (ï¿¦${s.cond.priceKRW})`:""}
                  </button>
                );
              })}
            </div>
          </div>
          {/* ì•¡ì…˜ ë²„íŠ¼ */}
          <div className="flex items-center justify-end gap-2">
            <button onClick={claimAdCoins} className="px-3 py-2 rounded-xl bg-emerald-500 hover:bg-emerald-400 text-sm">ê´‘ê³ ì½”ì¸+10</button>
            <button onClick={doBossLuck} className="px-3 py-2 rounded-xl bg-pink-500 hover:bg-pink-400 text-sm">ë³´ìŠ¤ ë£°ë ›</button>
            <button onClick={() => setRunning(false)} className="px-3 py-2 rounded-xl bg-gray-700 text-sm">ì¼ì‹œì •ì§€</button>
            <button onClick={startGame} className="px-3 py-2 rounded-xl bg-indigo-600 text-sm">ë‹¤ì‹œ</button>
          </div>
        </div>
      </div>

      {/* ì¢Œ/ìš° í„°ì¹˜ íŒ¨ë“œ (íˆ¬ëª…) */}
      <div className="absolute inset-x-0 bottom-28 top-14 z-10 flex">
        <div className="w-1/2 h-full" />
        <div className="w-1/2 h-full" />
      </div>

      {/* ëŒ€ì‰¬ í”Œë¡œíŒ… ë²„íŠ¼ */}
      <div className="absolute right-4 bottom-[96px] z-20">
        <button onClick={doDash} className="px-5 py-4 rounded-full bg-blue-600 active:bg-blue-500 text-base shadow-lg">ëŒ€ì‰¬</button>
      </div>

      <div className="absolute left-3 bottom-[96px] z-20 text-[11px] opacity-70">
        v1.1 (ëª¨ë°”ì¼) Â· 33ì¸µë§ˆë‹¤ ë³´ìŠ¤ Â· ë£°ë › 60% Â· í„°ì¹˜ ì´ë™/ëŒ€ì‰¬
      </div>
    </div>
  );
}
